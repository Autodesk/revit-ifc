//
// Revit IFC Import library: this library works with Autodesk(R) Revit(R) to import IFC files.
// Copyright (C) 2013  Autodesk, Inc.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Autodesk.Revit.DB;
using Autodesk.Revit.DB.IFC;
using Revit.IFC.Common.Utility;
using Revit.IFC.Common.Enums;
using Revit.IFC.Import.Enums;
using Revit.IFC.Import.Geometry;
using Revit.IFC.Import.Utility;

namespace Revit.IFC.Import.Data
{
   /// <summary>
   /// From IFC Documentation:
   /// A kind of surface constructed by sweeping potentially varying open cross sections along a curve horizontally (or near horizontally).
   /// The surface is generated by sweeping the CrossSections between CrossSectionPositions; 
   /// linear interpolation is assumed, unless transitions curves between cross section points are indicated by OpenCrossProfileDef.Tags. 
   /// The CrossSections are oriented with the Y axis of each profile facing upwards in +Z direction or vertically perpendicular to the Directrix,
   /// depending on the Attribute FixedAxisVertical value
   /// 
   /// The Geometry that this is supposed to represent is multiple potentially closed swept surfaces.  Not a swept
   /// solid.  For simplicity, this will take the first curve from the first ProfileDef and create a RuledSurface from that.
   /// This will at least display something for the IFCSectionedSurface.
   /// </summary>
   public class IFCSectionedSurface : IFCSurface
   {
      /// <summary>
      /// Curve along which cross sections occur.
      /// </summary>
      public IFCCurve Directrix { get; set; } = null;

      /// <summary>
      /// Cross sections.  Because of current limitations, only using the first cross section.
      /// </summary>
      public IFCProfileDef CrossSection { get; set; } = null;

      /// <summary>
      /// Get the Transform for the Directrix.
      /// Note:  This is taken largely from IFCSweptSurface, since that creates a Ruled Surface,
      /// which is what our geometry supports.
      /// </summary>
      /// <param name="pointOnSurface"></param>
      /// <returns>Transform to the Ruled Surface that (very) loosely represents the IFCSectionedSurface.</returns>
      public override Transform GetTransformAtPoint(XYZ pointOnSurface)
      {
         Transform retVal = Transform.Identity;
         XYZ originPoint = Directrix?.Curve.GetEndPoint(0);
         retVal.Origin = originPoint;
         return retVal;
      }


      /// <summary>
      /// Default Constructor
      /// </summary>
      protected IFCSectionedSurface()
      {
      }


      /// <summary>
      /// Process IFCSectionedSurface Attributes
      /// </summary>
      /// <param name="ifcSectionedSurface"></param>
      protected override void Process(IFCAnyHandle ifcSectionedSurface)
      {
         base.Process(ifcSectionedSurface);

         IFCAnyHandle directrix = IFCAnyHandleUtil.GetInstanceAttribute(ifcSectionedSurface, "Directrix");
         if (IFCAnyHandleUtil.IsNullOrHasNoValue(directrix))
         {
            Importer.TheLog.LogNullError(IFCEntityType.IfcCurve);
            return;
         }
         Directrix = IFCCurve.ProcessIFCCurve(directrix);

         IList<IFCAnyHandle> crossSections = IFCAnyHandleUtil.GetAggregateInstanceAttribute <List<IFCAnyHandle>>(ifcSectionedSurface, "CrossSections");
         if (crossSections?.Count > 0)
         {
            IFCAnyHandle firstCrossSection = crossSections[0];
            if (IFCAnyHandleUtil.IsNullOrHasNoValue(firstCrossSection))
            {
               Importer.TheLog.LogNullError(IFCEntityType.IfcProfileDef);
               return;
            }

            CrossSection = IFCProfileDef.ProcessIFCProfileDef(firstCrossSection);
         }
      }


      /// <summary>
      /// Create IFCSectionedSurface with handle.
      /// </summary>
      /// <param name="ifCSectionedSurface">Handle for ifcSectionedSurface.</param>
      protected IFCSectionedSurface(IFCAnyHandle ifCSectionedSurface)
      {
         Process(ifCSectionedSurface);
      }


      /// <summary>
      /// Process the IFCSectionedSurface.
      /// </summary>
      /// <param name="ifcSectionedSurface">Handle for the ifcSectionedSurface</param>
      /// <returns>IFCSectionedSurface object</returns>
      public static IFCSectionedSurface ProcessIFCSectionedSurface (IFCAnyHandle ifcSectionedSurface)
      {
         if (IFCAnyHandleUtil.IsNullOrHasNoValue(ifcSectionedSurface))
         {
            Importer.TheLog.LogNullError(IFCEntityType.IfcSectionedSurface);
            return null;
         }

         IFCEntity sectionedSurface;
         if (IFCImportFile.TheFile.EntityMap.TryGetValue(ifcSectionedSurface.StepId, out sectionedSurface))
            return sectionedSurface as IFCSectionedSurface;

         return new IFCSectionedSurface(ifcSectionedSurface);
      }


      /// <summary>
      /// This will just create a Ruled Surface, like IFCSurfaceOfLinearExtrusion
      /// </summary>
      /// <param name="lcs">The local coordinate system for the surface.  Can be null.</param>
      /// <returns>The surface that identifies the internal shape of the face.</returns>
      public override Surface GetSurface(Transform lcs)
      {
         // Currently there is no easy way to get the curve from the IFCProfile, so for now we assume that
         // the SweptCurve is an IFCSimpleProfile and its outer curve only contains one curve, which is the 
         // profile curve that we want
         IFCSimpleProfile simpleSweptCurve = CrossSection as IFCSimpleProfile;
         if (simpleSweptCurve == null)
         {
            Importer.TheLog.LogError(Id, "Currently only support IFCSimpleProfile for Cross-section", false);
            return null;
         }

         CurveLoop outerCurve = simpleSweptCurve?.GetTheOuterCurveLoop();
         CurveLoopIterator it = outerCurve?.GetCurveLoopIterator();
         Curve sweptCurve = it.Current;
         Curve profileCurve = Directrix?.Curve;

         if ((sweptCurve == null) || (profileCurve == null))
         {
            Importer.TheLog.LogError(Id, "At least one of the curves for the Ruled Surface is null", false);
            return null;
         }
         
         return RuledSurface.Create(profileCurve, sweptCurve);
      }
   }
}
